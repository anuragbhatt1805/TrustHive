{
  "version": 3,
  "sources": ["../../../common/interface/dist/auth-service.interface.js", "../../../common/interface/dist/auth-lambda.interface.js", "../../../common/interface/src/index.ts", "../src/index.ts", "../src/main.ts"],
  "sourcesContent": ["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=auth-service.interface.js.map", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=auth-lambda.interface.js.map", "// Main export file for @anuragbhatt1805/trusthive-interface-types\n\n// Auth Service interfaces\nexport * from './auth-service.interface';\n\n// Auth Lambda interfaces  \nexport * from './auth-lambda.interface';\n\n// Common shared interfaces\nexport * from './common.interface';\n\n// Re-export for convenience\nexport {\n  AuthServiceRequest,\n  AuthServiceResponse,\n  User,\n  LoginRequest,\n  RegisterRequest,\n  TokenPayload\n} from './auth-service.interface';\n\nexport {\n  AuthLambdaRequest,\n  AuthLambdaResponse,\n  LambdaLoginRequest,\n  LambdaRegisterRequest,\n  LambdaValidateRequest,\n  LambdaAuthUser,\n  LambdaLoginResponse,\n  LambdaRegisterResponse,\n  LambdaValidateResponse\n} from './auth-lambda.interface';\n\nexport {\n  ApiResponse,\n  PaginationRequest,\n  PaginationResponse,\n  ErrorResponse,\n  BaseEntity,\n  HealthCheckResponse\n} from './common.interface';\n// Updated interface\n", "// AWS Lambda handler entry point\nimport { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from 'aws-lambda';\nimport { AuthLambdaRequest, AuthLambdaResponse, handleAuth } from './main';\n\nexport const handler = async (\n  event: APIGatewayProxyEvent,\n  _context: Context\n): Promise<APIGatewayProxyResult> => {\n  // eslint-disable-next-line no-console\n  console.log('Lambda function invoked with event:', JSON.stringify(event, null, 2));\n\n  try {\n    // Parse the request body\n    let authRequest: AuthLambdaRequest;\n    \n    if (event.body) {\n      authRequest = JSON.parse(event.body);\n    } else {\n      // Handle GET request with query parameters\n      authRequest = {\n        action: event.queryStringParameters?.action || '',\n        email: event.queryStringParameters?.email,\n        password: event.queryStringParameters?.password,\n        token: event.queryStringParameters?.token\n      };\n    }\n\n    // Process the auth request\n    const authResponse: AuthLambdaResponse = await handleAuth(authRequest);\n\n    // Return the Lambda response\n    return {\n      statusCode: authResponse.statusCode,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*',\n        'Access-Control-Allow-Headers': 'Content-Type,Authorization',\n        'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'\n      },\n      body: JSON.stringify({\n        message: authResponse.message,\n        data: authResponse.data\n      })\n    };\n\n  } catch (error) {\n    // eslint-disable-next-line no-console\n    console.error('Error processing request:', error);\n\n    return {\n      statusCode: 500,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*'\n      },\n      body: JSON.stringify({\n        message: 'Internal server error'\n      })\n    };\n  }\n};\n", "// Main business logic for the auth lambda\n// For Lambda, we'll use a simpler approach without full Prisma to keep package size small\nimport {\n  AuthLambdaRequest,\n  AuthLambdaResponse,\n  LambdaLoginRequest,\n  LambdaRegisterRequest,\n  LambdaValidateRequest,\n  LambdaAuthUser\n} from '@anuragbhatt1805/trusthive-interface-types';\n\n// Mock data for now - in production, you could use a lightweight DB client\n// or call your auth service API endpoints\nconst mockUsers: { [key: string]: { id: string; email: string; password: string; name?: string } } = {};\n\nexport const handleAuth = async (request: AuthLambdaRequest): Promise<AuthLambdaResponse> => {\n  const { action } = request;\n\n  switch (action) {\n    case 'login':\n      return handleLogin(request as LambdaLoginRequest);\n    case 'register':\n      return handleRegister(request as LambdaRegisterRequest);\n    case 'validate':\n      return handleValidate(request as LambdaValidateRequest);\n    default:\n      return {\n        statusCode: 400,\n        message: 'Invalid action'\n      };\n  }\n};\n\nconst handleLogin = async (request: LambdaLoginRequest): Promise<AuthLambdaResponse> => {\n  const { email, password } = request;\n  \n  if (!email || !password) {\n    return {\n      statusCode: 400,\n      message: 'Email and password are required'\n    };\n  }\n\n  // eslint-disable-next-line no-console\n  console.log(`Processing login for: ${email}`);\n\n  // In production, you would:\n  // 1. Call your auth service API endpoint\n  // 2. Or use a lightweight DB client (not full Prisma)\n  // 3. Or use AWS RDS Data API\n\n  // Mock authentication\n  const user = mockUsers[email];\n  if (!user || user.password !== password) {\n    return {\n      statusCode: 401,\n      message: 'Invalid credentials'\n    };\n  }\n\n  const authUser: LambdaAuthUser = {\n    id: user.id,\n    email: user.email,\n    name: user.name\n  };\n  \n  return {\n    statusCode: 200,\n    message: 'Login successful',\n    data: {\n      token: 'mock-jwt-token',\n      user: authUser\n    }\n  };\n};\n\nconst handleRegister = async (request: LambdaRegisterRequest): Promise<AuthLambdaResponse> => {\n  const { email, password } = request;\n  \n  if (!email || !password) {\n    return {\n      statusCode: 400,\n      message: 'Email and password are required'\n    };\n  }\n\n  // eslint-disable-next-line no-console\n  console.log(`Processing registration for: ${email}`);\n\n  // Check if user already exists\n  if (mockUsers[email]) {\n    return {\n      statusCode: 409,\n      message: 'User already exists'\n    };\n  }\n\n  // Create user\n  const userId = `user_${Date.now()}`;\n  mockUsers[email] = {\n    id: userId,\n    email,\n    password,\n    name: request.name\n  };\n\n  const user: LambdaAuthUser = {\n    id: userId,\n    email,\n    name: request.name\n  };\n  \n  return {\n    statusCode: 201,\n    message: 'Registration successful',\n    data: { user }\n  };\n};\n\nconst handleValidate = async (request: LambdaValidateRequest): Promise<AuthLambdaResponse> => {\n  const { token } = request;\n  \n  if (!token) {\n    return {\n      statusCode: 400,\n      message: 'Token is required'\n    };\n  }\n\n  // eslint-disable-next-line no-console\n  console.log(`Validating token: ${token.substring(0, 10)}...`);\n\n  // Mock token validation\n  if (token === 'mock-jwt-token') {\n    const user: LambdaAuthUser = { email: 'user@example.com' };\n    \n    return {\n      statusCode: 200,\n      message: 'Token is valid',\n      data: { user }\n    };\n  }\n\n  return {\n    statusCode: 401,\n    message: 'Invalid token'\n  };\n};\n\n// Export the interface types for use in index.ts\nexport { AuthLambdaRequest, AuthLambdaResponse };\n"],
  "mappings": "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",
  "names": ["require_auth_service_interface", "__commonJSMin", "exports", "require_auth_lambda_interface", "__commonJSMin", "exports", "__exportStar", "exports", "index_exports", "__export", "handler", "__toCommonJS", "import_interface_types", "mockUsers", "handleAuth", "request", "action", "handleLogin", "handleRegister", "handleValidate", "email", "password", "user", "userId", "token", "handler", "event", "_context", "authRequest", "authResponse", "handleAuth", "error"]
}
